import Dict from "Dictionary"
import List from "List"



export alias Transition = Machine -> {}
export alias StateMap = Dictionary String Machine
export alias EventMap = Dictionary String String

/**
 * @constructor Machine
 * @param name        - String
 * @param states      - Dictionary String StateMachine
 * @param transitions - Dictionary String Transition
 */
export type Machine = Machine(String, Dictionary String Machine, Dictionary String String)

name :: Machine -> String
export name = where {
  Machine(n, _, _) =>
    n
}

children :: Machine -> StateMap
export children = where {
  Machine(_, c, _) =>
    c
}

eventMap :: Machine -> EventMap
export eventMap = where {
  Machine(_, _, t) =>
    t
}

subStates :: Machine -> List String
export subStates = pipe(
  children,
  Dict.keys,
)

events :: Machine -> List String
export events = pipe(
  eventMap,
  Dict.keys,
)

walkDown :: (Machine -> List a) -> Machine -> List a
export walkDown = (fn, m) => {
  walk :: Machine -> List a -> List a
  walk = (item, list) => where(list) {
    [] =>
      fn(item)

    [a, ...xs] =>
      [a, ...walk(item, xs)]
  }

  return walk(m, [])
}

allStates :: Machine -> List String
export allStates = walkDown(
  (m) => {
    n = name(m)
    return List.concat(
      subStates(m),
      pipe(
        children,
        Dict.values,
        map(subStates),
        List.flatten,
        map(mappend(n ++ ".")),
      )(m),
    )
  },
)

canTransitionTo :: String -> Machine -> Boolean
export canTransitionTo = (x, machine) => pipe(
  subStates,
  List.includes(x),
)(machine)

allEvents :: Machine -> List String
export allEvents = walkDown(
  (m) => List.concat(
    events(m),
    pipe(
      children,
      Dict.values,
      map(events),
      List.flatten,
    )(m),
  ),
)
